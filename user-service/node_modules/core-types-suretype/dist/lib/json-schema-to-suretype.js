"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertJsonSchemaToSureType = void 0;
const jsonpos_1 = require("jsonpos");
const core_types_1 = require("core-types");
const core_types_ts_1 = require("core-types-ts");
const core_types_json_schema_1 = require("core-types-json-schema");
const openapi_json_schema_1 = require("openapi-json-schema");
const json_schema_analysis_1 = require("./json-schema-analysis");
const utils_1 = require("./utils");
const helpers_1 = require("./helpers");
function extractAnnotations(schema) {
    const annotations = core_types_json_schema_1.helpers.annotateCoreTypes({}, schema);
    return annotations;
}
const schemaObjectVariableName = 'rawSchemaObject';
const defaultWarn = (msg, meta) => console.warn(msg, (meta === null || meta === void 0 ? void 0 : meta.path) ? `at [${meta === null || meta === void 0 ? void 0 : meta.path.join(', ')}]` : '');
function convertJsonSchemaToSureType(jsonSchema, opts) {
    const parsed = typeof jsonSchema === 'string'
        ? (0, jsonpos_1.getAstByString)(jsonSchema)
        : (0, jsonpos_1.getAstByObject)(jsonSchema);
    const { json, jsonString } = parsed;
    const { definitions } = json;
    if (!definitions)
        throw new core_types_1.UnsupportedError("JSON Schema must contain definitions");
    const { cyclic, nonCyclic } = (0, json_schema_analysis_1.analyzeSchema)(json);
    const { warn = defaultWarn, sourceFilename, useUnknown = true, forwardSchema = false, inlineTypes: _inlineTypes = true, exportType = true, exportSchema = true, exportValidator = true, exportEnsurer = true, exportTypeGuard = true, unsupported = 'warn', missingReference = 'warn', } = opts;
    const inlineTypes = forwardSchema || _inlineTypes;
    const contextFlags = new Set();
    const coreContext = {
        useUnknown,
        unsupported,
        handleUnsupported(msg) {
            if (unsupported === 'warn')
                warn(msg, this.meta());
            else if (unsupported === 'error')
                throw new core_types_1.UnsupportedError(msg, this.meta());
        },
        walk(...property) {
            return { ...this, path: [...this.path, ...property] };
        },
        warn(msg) {
            return warn(msg, this.meta());
        },
        meta() {
            return {
                path: this.path,
                filename: sourceFilename,
                source: jsonString
            };
        },
        set: (flag) => contextFlags.add(flag),
        path: [],
        topLevelType: '',
    };
    const definedDefinitions = Object.keys(definitions);
    [...cyclic, ...nonCyclic].forEach(definition => {
        if (!definedDefinitions.includes(definition)) {
            if (missingReference === 'error')
                throw new core_types_1.MissingReferenceError(definition, coreContext.meta());
            else if (missingReference === 'warn')
                coreContext.warn(`Reference to missing type: ${definition}, ignoring`);
            definitions[definition] = {}; // Becomes any/unknown
        }
    });
    const jsonSchemaAsCoreTypes = (0, core_types_json_schema_1.convertJsonSchemaToCoreTypes)(json);
    const coreTypes = (0, core_types_1.simplify)(jsonSchemaAsCoreTypes.data);
    Object.keys(definitions)
        .filter(key => {
        if (definitions[key] === false) {
            coreContext
                .walk(key)
                .handleUnsupported(`Top-level type being false is unsupported`);
            return false;
        }
        return true;
    });
    const isAnyCyclic = cyclic.length > 0;
    const rawSchemas = forwardSchema ? [...cyclic, ...nonCyclic] : cyclic;
    const jsonSchemaChunk = (!isAnyCyclic && !forwardSchema) ? [] : [
        core_types_ts_1.helpers.wrapAnnotations((0, helpers_1.createVariable)(schemaObjectVariableName, (0, helpers_1.translateValue)({
            definitions: Object.fromEntries(rawSchemas.map(key => [
                key,
                definitions[key] === true
                    ? {}
                    : definitions[key]
            ]))
        })), !isAnyCyclic ? {} :
            {
                description: 'These cyclic types need to be treated as raw ' +
                    'JSON Schema\n\n' +
                    'Cyclic types cannot be deduced from ' +
                    'typeof in TypeScript',
            })
    ];
    const cyclicSet = new Set(cyclic);
    // Types which depend on other types must come afterwards
    const orderedTypes = [...cyclic, ...nonCyclic];
    const convertedTypes = [];
    const statements = [
        ...jsonSchemaChunk,
        ...orderedTypes
            .flatMap(name => {
            const isCyclic = cyclicSet.has(name);
            const schemaObject = definitions[name];
            const ctx = {
                ...coreContext,
                topLevelType: name,
            };
            const exports = [];
            const { validatorSchemaName, regularValidatorName, ensureValidatorName, typeGuardValidatorName, } = (0, utils_1.getNames)(name);
            const typeName = name;
            exports.push((forwardSchema || isCyclic)
                ? createRawValidatorSchema(ctx, exportSchema, typeName, validatorSchemaName)
                : createValidatorSchema(ctx, exportSchema, typeName, validatorSchemaName, schemaObject));
            // TODO: Forward TypeScript types, if that's what the source is
            exports.push((inlineTypes || isCyclic)
                ? createPrettyType(ctx, coreTypes, typeName, useUnknown)
                : createTypeNameFromSchema(exportType, typeName, validatorSchemaName));
            if (exportValidator)
                exports.push(createRegularValidator(typeName, validatorSchemaName, regularValidatorName));
            if (exportEnsurer)
                exports.push(createEnsureValidator(typeName, validatorSchemaName, ensureValidatorName));
            if (exportTypeGuard)
                exports.push(createTypeGuardValidator(typeName, validatorSchemaName, typeGuardValidatorName));
            convertedTypes.push(typeName);
            return exports;
        })
    ];
    const importRegular = nonCyclic.length > 0;
    const importRaw = forwardSchema || cyclic.length > 0;
    const importCompile = exportValidator || exportEnsurer || exportTypeGuard;
    const importTypeOf = !inlineTypes && nonCyclic.length > 0;
    const importAnnotate = contextFlags.has('use-annotate');
    const importHeader = createImportHeader(importRegular, importRaw, importCompile, importTypeOf, importAnnotate);
    const sourceCode = [importHeader, ...statements]
        .map(tsNode => core_types_ts_1.helpers.generateCode(tsNode))
        .join("\n\n");
    const header = core_types_ts_1.helpers.createCodeHeader({
        ...opts,
        createdByPackage: utils_1.createdByPackage,
        createdByUrl: utils_1.createdByUrl,
    });
    return {
        data: header +
            sourceCode +
            (sourceCode.endsWith("\n") ? "" : "\n"),
        convertedTypes,
        notConvertedTypes: [],
    };
}
exports.convertJsonSchemaToSureType = convertJsonSchemaToSureType;
function createImportHeader(regular, raw, compile, TypeOf, annotate) {
    const hasNonTypeImport = regular || raw || compile || annotate;
    const importedMembers = [
        ...(regular ? ['suretype', 'v'] : []),
        ...(raw ? ['raw'] : []),
        ...(compile ? ['compile'] : []),
        ...(annotate ? ['annotate'] : []),
        ...(TypeOf ? ['TypeOf'] : []),
    ]
        .map(name => helpers_1.factory.createImportSpecifier(!hasNonTypeImport, undefined, helpers_1.t.ident(name)));
    return helpers_1.factory.createImportDeclaration(undefined, // decorators
    undefined, // modifiers
    helpers_1.factory.createImportClause(false, undefined, helpers_1.factory.createNamedImports(importedMembers)), helpers_1.factory.createStringLiteral('suretype', true));
}
function createPrettyType(ctx, doc, name, useUnknown) {
    const coreType = doc.types.find(type => type.name === name);
    if (coreType == null)
        throw new core_types_1.MissingReferenceError(name, ctx.meta());
    return (0, core_types_ts_1.convertSingleCoreTypeToTypeScriptAst)(coreType, { declaration: false, useUnknown });
}
function createTypeNameFromSchema(export_, typeName, schemaName) {
    return helpers_1.factory.createTypeAliasDeclaration(undefined, // decorators
    export_ ? (0, helpers_1.createExportModifier)() : undefined, // modifiers
    helpers_1.t.ident(typeName), undefined, // type parameters
    helpers_1.factory.createTypeReferenceNode("TypeOf", // type name
    [
        helpers_1.factory.createTypeQueryNode(helpers_1.t.ident(schemaName)),
    ]));
}
function createRegularValidator(typeName, validatorSchemaName, exportedName) {
    const exportNode = (0, helpers_1.createVariable)(exportedName, helpers_1.factory.createCallExpression(helpers_1.t.ident("compile"), undefined, // type arguments
    [helpers_1.t.ident(validatorSchemaName)]), { export: true });
    return core_types_ts_1.helpers.wrapAnnotations(exportNode, {
        description: `## Validate that a variable is a ${typeName}\n\n` +
            '@returns ValidationResult',
    });
}
function createEnsureValidator(typeName, validatorSchemaName, exportedName) {
    const exportNode = helpers_1.factory.createVariableStatement((0, helpers_1.createExportModifier)(), // modifiers
    helpers_1.factory.createVariableDeclarationList([
        helpers_1.factory.createVariableDeclaration(exportedName, undefined, // exclamation token
        undefined, // type node
        helpers_1.factory.createCallExpression(helpers_1.t.ident("compile"), [
            helpers_1.factory.createTypeQueryNode(helpers_1.t.ident(validatorSchemaName)),
            helpers_1.factory.createTypeReferenceNode(typeName)
        ], [
            helpers_1.t.ident(validatorSchemaName),
            helpers_1.factory.createObjectLiteralExpression([
                helpers_1.factory.createPropertyAssignment("ensure", helpers_1.t.true())
            ])
        ]))
    ], helpers_1.ts.NodeFlags.Const));
    return core_types_ts_1.helpers.wrapAnnotations(exportNode, {
        description: [
            `## Ensure a variable is a ${typeName}`,
            '',
            'This call will throw a ValidationError if the ' +
                `variable isn't a ${typeName}.`,
            '',
            `If the variable **is** a ${typeName}, the returned ` +
                'variable will be of that type.'
        ].join('\n')
    });
}
function createTypeGuardValidator(typeName, validatorSchemaName, exportedName) {
    const exportNode = helpers_1.factory.createVariableStatement((0, helpers_1.createExportModifier)(), // modifiers
    helpers_1.factory.createVariableDeclarationList([
        helpers_1.factory.createVariableDeclaration(exportedName, undefined, // exclamation token
        undefined, // type node
        helpers_1.factory.createCallExpression(helpers_1.t.ident("compile"), undefined, // type arguments
        [
            helpers_1.t.ident(validatorSchemaName),
            helpers_1.factory.createObjectLiteralExpression([
                helpers_1.factory.createPropertyAssignment("simple", helpers_1.t.true())
            ])
        ]))
    ], helpers_1.ts.NodeFlags.Const));
    return core_types_ts_1.helpers.wrapAnnotations(exportNode, {
        description: `## Validates that a variable is a ${typeName}\n\n` +
            '@returns boolean',
    });
}
function createRawValidatorSchema(_ctx, exportSchema, typeName, validatorSchemaName) {
    const exportNode = helpers_1.factory.createVariableStatement(exportSchema ? (0, helpers_1.createExportModifier)() : undefined, helpers_1.factory.createVariableDeclarationList([
        helpers_1.factory.createVariableDeclaration(validatorSchemaName, undefined, // exclamation token
        undefined, // type node
        (0, helpers_1.createCall)('raw', [
            helpers_1.t.ident(schemaObjectVariableName),
            helpers_1.t.string(typeName)
        ], [
            helpers_1.factory.createTypeReferenceNode(typeName)
        ]))
    ], helpers_1.ts.NodeFlags.Const));
    return !exportSchema
        ? exportNode
        : core_types_ts_1.helpers.wrapAnnotations(exportNode, { description: `The validation schema for a ${typeName}` });
}
function createValidatorSchema(ctx, exportSchema, typeName, validatorSchemaName, schemaObject) {
    const exportNode = helpers_1.factory.createVariableStatement(exportSchema ? (0, helpers_1.createExportModifier)() : undefined, helpers_1.factory.createVariableDeclarationList([
        helpers_1.factory.createVariableDeclaration(validatorSchemaName, undefined, // exclamation token
        undefined, // type node
        createValidator(ctx, schemaObject, { topLevelName: typeName }))
    ], helpers_1.ts.NodeFlags.Const));
    return !exportSchema
        ? exportNode
        : core_types_ts_1.helpers.wrapAnnotations(exportNode, { description: `The validation schema for a ${typeName}` });
}
function createValidator(ctx, def, { topLevelName, required = false, includeAnnotations = true, } = {}) {
    if (def === false) {
        ctx.handleUnsupported("false is not a valid schema type for core-types-suretype");
        return createAnyCall(ctx);
    }
    else if (def === true)
        return createAnyCall(ctx);
    const annotations = extractAnnotations(def);
    const suretypeAnnotations = (0, helpers_1.annotationsToSuretype)(annotations, topLevelName);
    const annotationsArgs = suretypeAnnotations ? [suretypeAnnotations] : [];
    const callAnnotate = (expr) => {
        ctx.set('use-annotate');
        return (0, helpers_1.createCall)('annotate', [...annotationsArgs, expr]);
    };
    const wrapDecorations = (expr) => !includeAnnotations
        ? expr
        : annotationsArgs.length === 0
            ? expr
            : topLevelName
                ? (0, helpers_1.createCall)('suretype', [...annotationsArgs, expr])
                : callAnnotate(expr);
    const wrapAnnotations = (expr) => wrapDecorations(expr);
    const wrapRequired = (expr) => required
        ? (0, helpers_1.createChainedCall)(expr, 'required')
        : expr;
    const wrap = (expr) => wrapAnnotations(wrapRequired(expr));
    const traversal = {
        ctx,
        def: def,
    };
    if (typeof def.$ref === 'string')
        return wrapAnnotations(wrapRef(ctx, def.$ref));
    if (Array.isArray(def.type))
        // Convert into 'anyOf'
        return wrap((0, helpers_1.createCall)("v.anyOf", [
            helpers_1.factory.createArrayLiteralExpression(def.type.map(type => createValidator(ctx, { ...def, type }, { includeAnnotations: false })))
        ]));
    if (def.type === 'null')
        return wrap(wrapValidatorGenerics(traversal, (0, helpers_1.createCall)("v.null")));
    else if (def.type === 'boolean')
        return wrap(wrapBoolean(traversal, (0, helpers_1.createCall)("v.boolean")));
    else if (def.type === 'integer')
        return wrap(wrapNumber(traversal, (0, helpers_1.createChainedCall)((0, helpers_1.createCall)("v.number"), 'integer')));
    else if (def.type === 'number')
        return wrap(wrapNumber(traversal, (0, helpers_1.createCall)("v.number")));
    else if (def.type === 'string')
        return wrap(wrapString(traversal, (0, helpers_1.createCall)("v.string")));
    else if (def.type === 'array')
        return wrap(wrapArray(traversal));
    else if (def.type === 'object')
        return wrap(wrapObject(traversal));
    if (Array.isArray(def.anyOf))
        return wrap(wrapValidatorGenerics(traversal, (0, helpers_1.createCall)("v.anyOf", [
            helpers_1.factory.createArrayLiteralExpression(def.anyOf.map(type => createValidator(ctx, type)))
        ]), { noAnyOf: true }));
    if (Array.isArray(def.allOf))
        return wrap(wrapValidatorGenerics(traversal, (0, helpers_1.createCall)("v.allOf", [
            helpers_1.factory.createArrayLiteralExpression(def.allOf.map(type => createValidator(ctx, type)))
        ]), { noAllOf: true }));
    return wrap(wrapValidatorGenerics(traversal, createAnyCall(ctx)));
}
function createAnyCall(ctx) {
    return (0, helpers_1.createCall)(ctx.useUnknown ? 'v.unknown' : 'v.any');
}
function createValidators(ctx, defs, parentType) {
    return defs
        .filter(def => typeof def !== 'object'
        ? true
        : (!def.type || def.type === parentType))
        .map(def => {
        var _a;
        return typeof def !== 'object' ? def : ({
            ...def,
            type: (_a = def.type) !== null && _a !== void 0 ? _a : parentType,
        });
    })
        .map((def, index) => createValidator(ctx.walk(index), def));
}
function wrapValidatorGenerics(traversal, expr, { noAnyOf = false, noAllOf = false, } = {}) {
    const { ctx, def, required } = traversal;
    if (required)
        expr = (0, helpers_1.createChainedCall)(expr, 'required');
    if (def.const !== undefined)
        expr = (0, helpers_1.createChainedCall)(expr, 'const', [(0, helpers_1.translateValue)(def.const)]);
    if (Array.isArray(def.enum))
        expr = (0, helpers_1.createChainedCall)(expr, 'enum', (0, helpers_1.translateValues)(def.enum));
    if (def.default !== undefined)
        expr = (0, helpers_1.createChainedCall)(expr, 'default', [(0, helpers_1.translateValue)(def.default)]);
    if (!noAnyOf && Array.isArray(def.anyOf)) {
        const subCtx = ctx.walk('anyOf');
        expr = (0, helpers_1.createChainedCall)(expr, 'anyOf', [
            helpers_1.factory.createArrayLiteralExpression(createValidators(subCtx, def.anyOf, def.type))
        ]);
    }
    if (!noAllOf && Array.isArray(def.allOf)) {
        const subCtx = ctx.walk('allOf');
        expr = (0, helpers_1.createChainedCall)(expr, 'allOf', [
            helpers_1.factory.createArrayLiteralExpression(createValidators(subCtx, def.allOf, def.type))
        ]);
    }
    return expr;
}
function wrapRef(ctx, name) {
    const decoded = (0, openapi_json_schema_1.decodeRefNameJsonSchema)(name);
    if (decoded === ctx.topLevelType)
        return (0, helpers_1.createCall)('v.recursive');
    if (decoded.match(/[#/ ]/)) {
        ctx.handleUnsupported(`Unsupported reference type: ${name}`);
        return createAnyCall(ctx);
    }
    return helpers_1.t.ident((0, utils_1.getNames)(decoded).validatorSchemaName);
}
function wrapBoolean(traversal, expr) {
    return wrapValidatorGenerics(traversal, expr);
}
function wrapNumber(traversal, expr) {
    const { def } = traversal;
    const wrapMultipleOf = (expr) => typeof def.multipleOf === 'number'
        ? (0, helpers_1.createChainedCall)(expr, 'multipleOf', [(0, helpers_1.translateValue)(def.multipleOf)])
        : expr;
    const wrapMinimum = (expr) => typeof def.minimum === 'number'
        ? (0, helpers_1.createChainedCall)(expr, 'gte', [(0, helpers_1.translateValue)(def.minimum)])
        : expr;
    const wrapExclusiveMinimum = (expr) => typeof def.exclusiveMinimum === 'number'
        ? (0, helpers_1.createChainedCall)(expr, 'gt', [(0, helpers_1.translateValue)(def.exclusiveMinimum)])
        : expr;
    const wrapMaximum = (expr) => typeof def.maximum === 'number'
        ? (0, helpers_1.createChainedCall)(expr, 'lt', [(0, helpers_1.translateValue)(def.maximum)])
        : expr;
    const wrapExclusiveMaximum = (expr) => typeof def.exclusiveMaximum === 'number'
        ? (0, helpers_1.createChainedCall)(expr, 'lte', [(0, helpers_1.translateValue)(def.exclusiveMaximum)])
        : expr;
    return wrapValidatorGenerics(traversal, wrapMaximum(wrapExclusiveMaximum(wrapMinimum(wrapExclusiveMinimum(wrapMultipleOf(expr))))));
}
function wrapString(traversal, expr) {
    const { def } = traversal;
    const wrapMinLength = (expr) => typeof def.minLength === 'number'
        ? (0, helpers_1.createChainedCall)(expr, 'minLength', [(0, helpers_1.translateValue)(def.minLength)])
        : expr;
    const wrapMaxLength = (expr) => typeof def.maxLength === 'number'
        ? (0, helpers_1.createChainedCall)(expr, 'maxLength', [(0, helpers_1.translateValue)(def.maxLength)])
        : expr;
    const wrapPattern = (expr) => typeof def.pattern === 'string'
        ? (0, helpers_1.createChainedCall)(expr, 'pattern', [(0, helpers_1.translateValue)(def.pattern)])
        : expr;
    const wrapFormat = (expr) => typeof def.format === 'string'
        ? (0, helpers_1.createChainedCall)(expr, 'format', [(0, helpers_1.translateValue)(def.format)])
        : expr;
    return wrapValidatorGenerics(traversal, wrapFormat(wrapPattern(wrapMaxLength(wrapMinLength(expr)))));
}
function wrapArray(traversal) {
    const { ctx, def } = traversal;
    const { items, additionalItems = true } = def;
    const isTuple = Array.isArray(items);
    const itemsArgs = Array.isArray(items)
        ? [
            helpers_1.factory.createArrayLiteralExpression(items
                .map((item, index) => createValidator(ctx.walk('items', index), item)), true)
        ]
        : items === undefined
            ? []
            : [createValidator(ctx.walk('items'), items)];
    if (!isTuple && additionalItems !== true)
        ctx.warn("Arrays with non-array items shouldn't set the " +
            "'additionalItems' property. Ignoring value.");
    if (def.contains !== undefined)
        ctx.handleUnsupported("Property 'contains' is not supported");
    if (def.uniqueItems !== undefined)
        ctx.handleUnsupported("Property 'uniqueItems' is not supported");
    const wrapMinItems = (expr) => def.minItems === undefined
        ? expr
        : (0, helpers_1.createChainedCall)(expr, 'minItems', [(0, helpers_1.translateValue)(def.minItems)]);
    const wrapMaxItems = (expr) => def.maxItems === undefined
        ? expr
        : (0, helpers_1.createChainedCall)(expr, 'maxItems', [(0, helpers_1.translateValue)(def.maxItems)]);
    const wrapAdditionalItems = (expr) => !isTuple
        ? expr // Ignored for arrays, only applicable for tuples
        : additionalItems === true
            ? expr
            : additionalItems === false
                ? (0, helpers_1.createChainedCall)(expr, 'additional', [helpers_1.t.false()])
                : (0, helpers_1.createChainedCall)(expr, 'additional', [createValidator(ctx, additionalItems)]);
    return wrapValidatorGenerics(traversal, wrapAdditionalItems(wrapMaxItems(wrapMinItems((0, helpers_1.createCall)("v.array", itemsArgs)))));
}
function wrapObject(traversal) {
    const { ctx, def } = traversal;
    const { required = [] } = def;
    const properties = def.properties
        ? helpers_1.factory.createObjectLiteralExpression(Object.keys(def.properties)
            .map(prop => helpers_1.factory.createPropertyAssignment(prop, createValidator(traversal.ctx.walk('properties', prop), def.properties[prop], { required: required.includes(prop) }))), true)
        : (0, helpers_1.translateValue)({});
    const additionalProperties = def.additionalProperties === undefined
        ? true
        : def.additionalProperties === false
            ? false
            : Object.keys(def.additionalProperties).length === 0
                ? true
                : def.additionalProperties;
    const wrapAdditionalProperties = (expr) => additionalProperties === true
        ? (0, helpers_1.createChainedCall)(expr, 'additional', [helpers_1.t.true()])
        : additionalProperties === false
            ? expr
            : (0, helpers_1.createChainedCall)(expr, 'additional', [
                createValidator(ctx.walk('additionalProperties'), additionalProperties)
            ]);
    if (def.patternProperties !== undefined)
        ctx.handleUnsupported("Property 'patternProperties' not supported");
    if (def.propertyNames !== undefined)
        ctx.handleUnsupported("Property 'propertyNames' not supported");
    if (def.minProperties !== undefined)
        ctx.handleUnsupported("Property 'minProperties' not supported");
    if (def.maxProperties !== undefined)
        ctx.handleUnsupported("Property 'maxProperties' not supported");
    if (def.dependencies !== undefined)
        ctx.handleUnsupported("Property 'dependencies' not supported");
    return wrapValidatorGenerics(traversal, wrapAdditionalProperties((0, helpers_1.createCall)("v.object", [properties])));
}
