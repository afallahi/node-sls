#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = require("chalk");
const oppa_1 = require("oppa");
const core_types_1 = require("core-types");
const converter_1 = require("../converter");
const batch_convert_1 = require("../batch-convert");
const convert_json_schema_1 = require("../convert-json-schema");
const convert_graphql_1 = require("../convert-graphql");
const convert_typescript_1 = require("../convert-typescript");
const convert_core_types_1 = require("../convert-core-types");
const convert_suretype_1 = require("../convert-suretype");
const package_1 = require("../package");
const utils_1 = require("../utils");
const implementations = [
    { ts: "TypeScript" },
    { jsc: "JSON Schema" },
    { gql: "GraphQL" },
    { oapi: "Open API" },
    { st: "SureType" },
    { ct: "core-types" },
];
const oppaInstance = (0, oppa_1.oppa)({
    version: require("../../package.json").version,
    usage: "typeconv [options] file ...",
    noVersionAlias: true,
})
    .add({
    name: 'verbose',
    alias: 'v',
    type: 'boolean',
    negatable: false,
    description: "Verbose informational output",
    default: false,
})
    .add({
    name: 'dry-run',
    type: 'boolean',
    negatable: false,
    description: "Prepare and perform conversion, but write no output",
    default: false,
})
    .add({
    name: 'hidden',
    type: 'boolean',
    negatable: true,
    description: [
        "Include hidden files, i.e. files in .gitignore,",
        "files beginning with '.' and the '.git' directory",
    ],
    default: true,
})
    .add({
    name: 'from-type',
    argumentName: 'type',
    alias: 'f',
    type: 'string',
    description: "Type system to convert from",
    values: implementations,
})
    .add({
    name: 'to-type',
    argumentName: 'type',
    alias: 't',
    type: 'string',
    description: "Type system to convert to",
    values: implementations,
})
    .add({
    name: 'shortcut',
    type: 'boolean',
    description: [
        "Shortcut conversion if possible (bypassing core-types).",
        "This is possible between SureType, JSON Schema and Open API",
        "to preserve all features which would otherwise be erased."
    ],
    default: true,
    negatable: true,
})
    .add({
    name: 'output-directory',
    argumentName: 'dir',
    alias: 'o',
    type: 'string',
    description: "Output directory. Defaults to the same as the input files.",
})
    .add({
    name: 'output-extension',
    argumentName: 'ext',
    alias: 'O',
    type: 'string',
    description: [
        "Output filename extension to use.",
        "Defaults to 'ts'/'d.ts', 'json', 'yaml' and 'graphql'.",
        "Use '-' to not save a file, but output to stdout instead."
    ],
})
    .add({
    name: 'strip-annotations',
    type: 'boolean',
    description: "Removes all annotations (descriptions, comments, ...)",
    default: false,
})
    .group({
    name: "TypeScript",
    backgroundColor: '#0077c8',
    color: '#fff',
})
    .add({
    name: 'ts-declaration',
    type: 'boolean',
    description: "Output TypeScript declarations",
    default: false,
})
    .add({
    name: 'ts-disable-lint-header',
    type: 'boolean',
    description: "Output comments for disabling linting",
    default: true,
})
    .add({
    name: 'ts-descriptive-header',
    type: 'boolean',
    description: "Output the header comment",
    default: true,
})
    .add({
    name: 'ts-use-unknown',
    type: 'boolean',
    description: "Use 'unknown' type instead of 'any'",
    default: true,
})
    .add({
    name: 'ts-non-exported',
    type: 'string',
    argumentName: 'method',
    description: "Strategy for non-exported types",
    default: 'include-if-referenced',
    values: [
        { 'fail': "Fail conversion" },
        { 'ignore': [
                "Don't include non-exported types,",
                "even if referenced",
            ] },
        { 'include': "Include non-exported types" },
        { 'inline': [
                "Don't include non-exported types, ",
                "inline them if necessary.",
                "Will fail on cyclic types"
            ] },
        { 'include-if-referenced': [
                "Include non-exported types only if they",
                "are referenced from exported types",
            ] },
    ],
})
    .group({
    name: "GraphQL",
    backgroundColor: '#e10098',
    color: '#fff',
})
    .add({
    name: 'gql-unsupported',
    argumentName: 'method',
    type: 'string',
    description: "Method to use for unsupported types",
    values: [
        { ignore: 'Ignore (skip) type' },
        { warn: 'Ignore type, but warn' },
        { error: 'Throw an error' },
    ],
})
    .add({
    name: 'gql-null-typename',
    argumentName: 'name',
    type: 'string',
    description: "Custom type name to use for null",
})
    .group({
    name: "Open API",
    backgroundColor: '#85ea2d',
    color: '#222',
})
    .add({
    name: 'oapi-format',
    argumentName: 'fmt',
    type: 'string',
    description: "Output format for Open API",
    values: [
        { json: "JSON" },
        { yaml: "YAML ('yml' is also allowed)" },
    ],
    default: 'yaml',
})
    .add({
    name: 'oapi-title',
    argumentName: 'title',
    type: 'string',
    description: [
        "Open API title to use in output document.",
        "Defaults to the input filename."
    ],
})
    .add({
    name: 'oapi-version',
    argumentName: 'version',
    type: 'string',
    description: "Open API document version to use in output document.",
    default: '1',
})
    .group({
    name: "SureType",
    backgroundColor: '#4f81a0',
    color: '#fff',
})
    .add({
    name: 'st-ref-method',
    argumentName: 'method',
    type: 'string',
    description: "SureType reference export method",
    values: [
        { "no-refs": "Don't ref anything, inline all types" },
        { "provided": "Reference types that are explicitly exported" },
        { "ref-all": "Ref all provided types and those with names" },
    ],
    default: 'provided',
})
    .add({
    name: 'st-missing-ref',
    argumentName: 'method',
    type: 'string',
    description: "What to do when detecting an unresolvable reference",
    values: [
        { "ignore": "Ignore; skip type or cast to any" },
        { "warn": "Same as 'ignore', but warn" },
        { "error": "Fail conversion" },
    ],
    default: 'warn',
})
    .add({
    name: 'st-inline-types',
    type: 'boolean',
    default: true,
    description: "Inline pretty typescript types aside validator code",
})
    .add({
    name: 'st-export-type',
    type: 'boolean',
    description: [
        "Export the deduced types (or the pretty types,",
        "depending on --st-inline-types)",
    ],
    default: true,
})
    .add({
    name: 'st-export-schema',
    type: 'boolean',
    description: "Export validator schemas",
    default: false,
})
    .add({
    name: 'st-export-validator',
    type: 'boolean',
    description: "Export regular validators",
    default: true,
})
    .add({
    name: 'st-export-ensurer',
    type: 'boolean',
    description: "Export 'ensurer' validators",
    default: true,
})
    .add({
    name: 'st-export-type-guard',
    type: 'boolean',
    description: "Export type guards (is* validators)",
    default: true,
})
    .add({
    name: 'st-use-unknown',
    type: 'boolean',
    description: "Use 'unknown' type instead of 'any'",
    default: true,
})
    .add({
    name: 'st-forward-schema',
    type: 'boolean',
    description: [
        "Forward the JSON Schema, and create an untyped validator schema",
        "with the raw JSON Schema under the hood",
    ],
    default: false,
});
const result = oppaInstance.parse();
const printHelp = () => oppaInstance.showHelp(true);
const { args, rest: globFiles } = result;
const { verbose, "dry-run": dryRun, hidden, "from-type": fromType, "to-type": toType, shortcut, "output-directory": outputDirectory, "output-extension": outputExtension, "strip-annotations": doStripAnnotations, 
// TypeScript
"ts-declaration": tsDeclaration, "ts-disable-lint-header": tsDisableLintHeader, "ts-descriptive-header": tsDescriptiveHeader, "ts-use-unknown": tsUseUnknown, "ts-non-exported": tsNonExported, 
// JSON Schema
// GraphQL
"gql-unsupported": gqlUnsupported, "gql-null-typename": gqlNullTypename, 
// Open API
"oapi-format": oapiFormat, "oapi-title": oapiTitle, "oapi-version": oapiVersion, 
// suretype
"st-ref-method": stRefMethod, "st-missing-ref": stMissingReference, "st-inline-types": stInlineTypes, "st-export-type": stExportType, "st-export-schema": stExportSchema, "st-export-validator": stExportValidator, "st-export-ensurer": stExportEnsurer, "st-export-type-guard": stExportTypeGuard, "st-use-unknown": stUseUnknown, "st-forward-schema": stForwardSchema, } = args;
const typeImplementations = implementations.map(obj => Object.keys(obj)[0]);
if (!(0, utils_1.ensureType)(fromType, 'type system identifyer', typeImplementations, printHelp))
    throw new Error();
if (!(0, utils_1.ensureType)(toType, 'type system identifyer', typeImplementations, printHelp))
    throw new Error();
if (!(0, utils_1.ensureType)(tsNonExported, 'ts-non-exported', ['fail', 'ignore', 'include', 'inline', 'include-if-referenced'], printHelp))
    throw new Error();
if (!(0, utils_1.ensureType)(stRefMethod, 'ref-method', ['no-refs', 'provided', 'ref-all', undefined], printHelp))
    throw new Error();
if (!(0, utils_1.ensureType)(stMissingReference, 'missing-ref', ['ignore', 'warn', 'error', undefined], printHelp))
    throw new Error();
const getReader = () => {
    return fromType === 'ts'
        ? (0, convert_typescript_1.getTypeScriptReader)({
            nonExported: tsNonExported,
        })
        : fromType === 'jsc'
            ? (0, convert_json_schema_1.getJsonSchemaReader)()
            : fromType === 'oapi'
                ? (0, convert_json_schema_1.getOpenApiReader)()
                : fromType === 'gql'
                    ? (0, convert_graphql_1.getGraphQLReader)({
                        unsupported: gqlUnsupported,
                    })
                    : fromType === 'st'
                        ? (0, convert_suretype_1.getSureTypeReader)({
                            refMethod: stRefMethod,
                            nameConflict: 'error',
                        })
                        : (0, convert_core_types_1.getCoreTypesReader)();
};
const getWriter = () => {
    return toType === 'ts'
        ? (0, convert_typescript_1.getTypeScriptWriter)({
            userPackage: package_1.userPackage,
            userPackageUrl: package_1.userPackageUrl,
            declaration: tsDeclaration,
            noDisableLintHeader: tsDisableLintHeader,
            noDescriptiveHeader: tsDescriptiveHeader,
            useUnknown: tsUseUnknown,
        })
        : toType === 'jsc'
            ? (0, convert_json_schema_1.getJsonSchemaWriter)()
            : toType === 'oapi'
                ? (0, convert_json_schema_1.getOpenApiWriter)({
                    format: oapiFormat,
                    title: oapiTitle,
                    version: oapiVersion,
                })
                : toType === 'gql'
                    ? (0, convert_graphql_1.getGraphQLWriter)({
                        unsupported: gqlUnsupported,
                        nullTypeName: gqlNullTypename,
                    })
                    : toType === 'st'
                        ? (0, convert_suretype_1.getSureTypeWriter)({
                            inlineTypes: stInlineTypes,
                            exportType: stExportType,
                            exportSchema: stExportSchema,
                            exportValidator: stExportValidator,
                            exportEnsurer: stExportEnsurer,
                            exportTypeGuard: stExportTypeGuard,
                            useUnknown: stUseUnknown,
                            forwardSchema: stForwardSchema,
                            missingReference: stMissingReference,
                        })
                        : (0, convert_core_types_1.getCoreTypesWriter)();
};
(async () => {
    const cwd = process.cwd();
    const converter = (0, converter_1.makeConverter)(getReader(), getWriter(), {
        ...(!doStripAnnotations ? {} :
            { map: (node => (0, core_types_1.stripAnnotations)(node)) }),
        cwd,
        shortcut,
    });
    const before = Date.now();
    const result = await (0, batch_convert_1.batchConvertGlob)(converter, globFiles, {
        outputDirectory,
        outputExtension: outputExtension !== null && outputExtension !== void 0 ? outputExtension : (toType === 'ts' ? '.ts'
            : toType === 'jsc' ? '.json'
                : toType === 'oapi' ? `.${oapiFormat}`
                    : toType === 'gql' ? '.graphql'
                        : toType === 'st' ? '.ts'
                            : '.json'),
        verbose,
        dryRun,
        hidden,
    });
    const after = Date.now();
    const sec = ((after - before) / 1000).toFixed(1);
    console.error((0, chalk_1.bold)(`ðŸ’¡ Converted ${result.types} types in ${result.files} files, ` +
        `in ${sec}s`));
})()
    .catch((err) => {
    console.error(process.env.DEBUG ? err === null || err === void 0 ? void 0 : err.stack : err === null || err === void 0 ? void 0 : err.message);
    process.exit(1);
});
