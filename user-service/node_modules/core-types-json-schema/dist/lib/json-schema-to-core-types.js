"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.complexProps = exports.convertJsonSchemaToCoreTypes = void 0;
const jsonpos_1 = require("jsonpos");
const openapi_json_schema_1 = require("openapi-json-schema");
const core_types_1 = require("core-types");
const annotations_1 = require("./annotations");
const walkDown = (ctx, child) => ({ ...ctx, path: [...ctx.path, child] });
function convertJsonSchemaToCoreTypes(schema, options = {}) {
    const parsed = typeof schema === 'string'
        ? (0, jsonpos_1.getAstByString)(schema)
        : (0, jsonpos_1.getAstByObject)(schema);
    const { json } = parsed;
    const { definitions } = json;
    const doc = {
        version: 1,
        types: Object
            .keys(definitions !== null && definitions !== void 0 ? definitions : {})
            .map(name => {
            var _a;
            const typeSchema = (definitions !== null && definitions !== void 0 ? definitions : {})[name];
            const ctx = {
                locByPath() {
                    return {
                        path: this.path,
                        loc: (0, jsonpos_1.getLocation)(parsed, { dataPath: this.path, markIdentifier: true }),
                    };
                },
                path: ['definitions', name],
                throwUnsupportedError(message, meta) {
                    meta = { ...meta };
                    if (!meta.path)
                        meta.path = this.path;
                    if (!meta.loc)
                        meta.loc = (0, jsonpos_1.getLocation)(parsed, { dataPath: this.path, markIdentifier: true });
                    throw new core_types_1.UnsupportedError(message, meta);
                },
                defaultAdditionalProperties: (_a = options.defaultAdditionalProperties) !== null && _a !== void 0 ? _a : true,
            };
            const node = fromSchema(typeSchema, ctx);
            const namedNode = { ...node, name };
            return namedNode;
        }),
    };
    return {
        data: doc,
        convertedTypes: doc.types.map(({ name }) => name),
        notConvertedTypes: [],
    };
}
exports.convertJsonSchemaToCoreTypes = convertJsonSchemaToCoreTypes;
exports.complexProps = new Set(['anyOf', 'allOf', 'oneOf', 'then', 'else']);
/**
 * If a schema has an anyOf, allOf or oneOf, or (if-)then-else, the parent type
 * info will be pushed down to these (not overwriting, but prepending)
 */
function pushDown(schema, ctx) {
    const { $ref, type, // JSONSchema7TypeName | JSONSchema7TypeName[];
    enum: _enum, ///: JSONSchema7Type[];
    const: _const, // : JSONSchema7Type;
    items, // JSONSchema7Definition | JSONSchema7Definition[];
    additionalItems, // JSONSchema7Definition;
    required, // string[];
    properties, // { [key: string]: JSONSchema7Definition; };
    // patternProperties, // { [key: string]: JSONSchema7Definition; };
    additionalProperties, // JSONSchema7Definition;
    then, // JSONSchema7Definition;
    else: _else, // JSONSchema7Definition;
    allOf: _allOf, // JSONSchema7Definition[];
    anyOf: _anyOf, // JSONSchema7Definition[];
    oneOf: _oneOf, // JSONSchema7Definition[];
     } = schema;
    const allOf = !_allOf || typeof _allOf !== 'object'
        ? null
        : _allOf.filter((entry) => entry && typeof entry === 'object');
    const anyOf = !_anyOf || typeof _anyOf !== 'object'
        ? null
        : _anyOf.filter((entry) => entry && typeof entry === 'object');
    const oneOf = !_oneOf || typeof _oneOf !== 'object'
        ? null
        : _oneOf.filter((entry) => entry && typeof entry === 'object');
    const mergeDown = (container, subSchema) => {
        var _a, _b, _c, _d, _e;
        const isOnlyOrSame = (a, b) => !(a && b && !(0, core_types_1.isEqual)(a, b));
        if (!isOnlyOrSame($ref, subSchema.$ref))
            ctx.throwUnsupportedError(`Cannot have $ref in a node *and* in its '${container}'`, {
                blob: schema
            });
        if (!isOnlyOrSame(type, subSchema.type))
            ctx.throwUnsupportedError(`Cannot have 'type' in a node *and* in its '${container}'`, {
                blob: schema
            });
        if (_enum) {
            if (!subSchema.enum)
                subSchema.enum = _enum;
            else {
                const newEnum = (0, core_types_1.intersection)(_enum, subSchema.enum);
                if (newEnum.length === 0)
                    throw new core_types_1.MalformedTypeError("Cannot merge types with non-intersecting enums", {
                        path: ctx.path,
                        blob: {
                            child: [...ctx.path, container],
                        }
                    });
                subSchema.enum = newEnum;
            }
        }
        if (_const !== undefined) {
            if (subSchema.const !== undefined) {
                if ((0, core_types_1.isEqual)(_const, subSchema.const))
                    throw new core_types_1.MalformedTypeError("Cannot merge types with mismatching const", {
                        path: ctx.path,
                        blob: {
                            child: [...ctx.path, container],
                        }
                    });
            }
            else
                subSchema.const = _const;
        }
        subSchema.items = (_a = subSchema.items) !== null && _a !== void 0 ? _a : items;
        subSchema.additionalItems =
            (_b = subSchema.additionalItems) !== null && _b !== void 0 ? _b : additionalItems;
        if (required !== undefined || subSchema.required !== undefined)
            subSchema.required =
                (0, core_types_1.union)((_c = subSchema.required) !== null && _c !== void 0 ? _c : [], required !== null && required !== void 0 ? required : []);
        if ((typeof properties === 'undefined') !==
            (typeof subSchema.properties === 'undefined'))
            (_d = subSchema.properties) !== null && _d !== void 0 ? _d : (subSchema.properties = properties);
        else if (typeof properties !== 'undefined') {
            const propA = properties;
            const propB = subSchema.properties;
            // Merge properties
            const keysA = Object.keys(propA);
            const keysB = Object.keys(propB);
            const combinedKeys = (0, core_types_1.union)(keysA, keysB);
            const ret = {};
            combinedKeys.forEach(key => {
                if (propA[key] !== undefined)
                    ret[key] = propB[key];
                else if (propB[key] !== undefined)
                    ret[key] = propA[key];
                else
                    // Merge
                    ret[key] = { allOf: [propA[key], propB[key]] };
            });
        }
        if ((typeof additionalProperties === 'undefined') !==
            (typeof subSchema.additionalProperties === 'undefined'))
            (_e = subSchema.additionalProperties) !== null && _e !== void 0 ? _e : (subSchema.additionalProperties = additionalProperties);
        else if (typeof additionalProperties !== 'undefined') {
            // Merge
            subSchema.additionalProperties = {
                allOf: [
                    subSchema.additionalProperties,
                    additionalProperties
                ]
            };
        }
        // TODO: Consider implementing fallback support for patternProperties
        // TODO: Implement annotations
        // title // string;
        // description // string;
        // _default // JSONSchema7Type;
        // examples // JSONSchema7Type;
    };
    if (then && typeof then === 'object')
        mergeDown('then', then);
    if (_else && typeof _else === 'object')
        mergeDown('else', _else);
    if (allOf && typeof allOf === 'object')
        allOf.forEach(entry => mergeDown('allOf', entry));
    if (anyOf && typeof anyOf === 'object')
        anyOf.forEach(entry => mergeDown('anyOf', entry));
    if (oneOf && typeof oneOf === 'object')
        oneOf.forEach(entry => mergeDown('oneOf', entry));
    return {
        ...(then && typeof then === 'object' ? { then } : {}),
        ...(_else && typeof _else === 'object' ? { else: _else } : {}),
        ...(allOf && typeof allOf === 'object' ? { allOf } : {}),
        ...(anyOf && typeof anyOf === 'object' ? { anyOf } : {}),
        ...(oneOf && typeof oneOf === 'object' ? { oneOf } : {}),
    };
}
/**
 * If a schema has an anyOf, allOf or oneOf, or (if-)then-else, these will be
 * converted to the core-types type 'and' or 'or':
 *   - anyOf, oneOf and [then, else] become an 'or' type
 *   - allOf becomes an 'and' type
 */
function fromComplex(schema, ctx) {
    const { then, else: _else, allOf, anyOf, oneOf, } = schema;
    const conditionals = [
        ...(then ? [[walkDown(ctx, 'then'), then]] : []),
        ...(_else ? [[walkDown(ctx, 'else'), _else]] : []),
    ];
    const ors = [
        ...(anyOf
            ? anyOf.map((node, index) => [walkDown(walkDown(ctx, 'anyOf'), index), node])
            : []),
        ...(oneOf
            ? oneOf.map((node, index) => [walkDown(walkDown(ctx, 'oneOf'), index), node])
            : []),
    ];
    const ands = [
        ...(allOf
            ? allOf.map((node, index) => [walkDown(walkDown(ctx, 'allOf'), index), node])
            : []),
    ];
    return {
        type: 'and',
        and: [
            {
                type: 'or',
                or: conditionals.map(([ctx, v]) => fromSchema(v, ctx)),
            },
            {
                type: 'or',
                or: ors.map(([ctx, v]) => fromSchema(v, ctx)),
            },
            {
                type: 'and',
                and: ands.map(([ctx, v]) => fromSchema(v, ctx)),
            },
        ]
    };
}
function isComplex(schema) {
    return typeof schema === 'object' &&
        Object.keys(schema).some(prop => exports.complexProps.has(prop));
}
function fromSchema(schema, ctx) {
    if (typeof schema === 'boolean')
        ctx.throwUnsupportedError("Boolean JSON Schema definition not supported", { blob: { schema } });
    else if (isComplex(schema))
        return fromComplex(pushDown(schema, ctx), ctx);
    if (typeof schema === 'undefined')
        ctx.throwUnsupportedError(`Internal error`, { blob: { schema } });
    const makeRefType = (ref) => ({ type: 'ref', ref: (0, openapi_json_schema_1.decodeRefNameJsonSchema)(ref) });
    const wrapRefType = (node) => schema.$ref === undefined
        ? node
        : {
            type: 'and',
            and: [node, makeRefType(schema.$ref)],
        };
    const { const: _const, enum: _enum } = schema;
    const constEnum = {
        ...(typeof _const !== 'undefined' ? { const: _const } : {}),
        ...(typeof _enum !== 'undefined' ? { enum: _enum } : {}),
    };
    if (schema.type === undefined) {
        if (schema.$ref)
            return { ...makeRefType(schema.$ref), ...constEnum };
        else
            return { type: 'any', ...constEnum };
    }
    const types = (0, core_types_1.ensureArray)(schema.type)
        .map(type => fromSchemaAndType(schema, type, constEnum, ctx));
    if (types.length === 1)
        return wrapRefType(types[0]);
    return wrapRefType({ type: 'or', or: types });
}
function fromSchemaAndType(schema, type, constEnum, ctx) {
    var _a, _b, _c, _d;
    if (isPrimitiveType(type)) {
        if (type === 'null')
            return (0, annotations_1.annotateCoreTypes)({ type: 'null' }, schema);
        else
            return (0, annotations_1.annotateCoreTypes)({ type, ...constEnum }, schema);
    }
    else if (type === 'array') {
        if (Array.isArray(schema.items)) {
            return (0, annotations_1.annotateCoreTypes)({
                type: 'tuple',
                elementTypes: schema.items.map(item => fromSchema(item, walkDown(ctx, 'items'))),
                additionalItems: typeof schema.additionalItems === 'undefined'
                    ? true
                    : typeof schema.additionalItems === 'boolean'
                        ? schema.additionalItems
                        : fromSchema(schema.additionalItems, walkDown(ctx, 'additionalItems')),
                minItems: (_a = schema.minItems) !== null && _a !== void 0 ? _a : 0,
                ...constEnum,
            }, schema);
        }
        else if (schema.items === false) {
            return (0, annotations_1.annotateCoreTypes)({
                type: 'tuple',
                elementTypes: [],
                additionalItems: false,
                minItems: 0,
                ...constEnum,
            }, schema);
        }
        else {
            return (0, annotations_1.annotateCoreTypes)({
                type: 'array',
                elementType: (typeof schema.items === 'undefined' ||
                    schema.items === true)
                    ? { type: 'any' }
                    : fromSchema(schema.items, walkDown(ctx, 'items')),
                ...constEnum,
            }, schema);
        }
    }
    else if (type === 'object') {
        const required = new Set((_b = schema.required) !== null && _b !== void 0 ? _b : []);
        const additionalProperties = (_c = schema.additionalProperties) !== null && _c !== void 0 ? _c : ctx.defaultAdditionalProperties;
        return (0, annotations_1.annotateCoreTypes)({
            type: 'object',
            properties: Object.fromEntries(Object.entries((_d = schema.properties) !== null && _d !== void 0 ? _d : {})
                .map(([prop, value]) => [
                prop,
                {
                    node: fromSchema(value, walkDown(walkDown(ctx, 'properties'), prop)),
                    required: required.has(prop),
                }
            ])),
            additionalProperties: typeof additionalProperties === 'boolean'
                ? additionalProperties
                : fromSchema(additionalProperties, walkDown(ctx, 'additionalProperties')),
            ...constEnum,
        }, schema);
    }
    else
        ctx.throwUnsupportedError(`Unsupported JSON Schema type "${type}"`, { blob: { schema } });
}
const isPrimitiveType = (type) => ["string", "number", "integer", "boolean", "null"].includes(type);
