"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertGraphqlToCoreTypes = exports.getGraphqlAst = void 0;
const core_types_1 = require("core-types");
const graphql_1 = require("graphql");
const annotation_1 = require("./annotation");
const gql_utils_1 = require("./gql-utils");
const utils_1 = require("./utils");
function getGraphqlAst(source) {
    return (0, graphql_1.parse)(source);
}
exports.getGraphqlAst = getGraphqlAst;
function convertGraphqlToCoreTypes(source, options) {
    var _a;
    const { warn = (message) => console.warn(message), unsupported = 'ignore', } = options !== null && options !== void 0 ? options : {};
    let document;
    try {
        document = getGraphqlAst(source);
    }
    catch (err) {
        if (err instanceof graphql_1.GraphQLError)
            (0, core_types_1.throwRelatedError)(err, {
                source,
                loc: (0, utils_1.gqlLocationsToCoreTypesLocation)(source, (_a = err.locations) !== null && _a !== void 0 ? _a : [])
            });
        throw err;
    }
    if (document.kind !== graphql_1.Kind.DOCUMENT)
        throw new core_types_1.UnsupportedError(`Invalid document type "${document.kind}"`, {
            blob: document,
            path: [],
            loc: document.loc,
        });
    const notConvertedTypes = [];
    const types = document.definitions
        .map((definition) => {
        var _a, _b, _c, _d;
        if (definition.kind === graphql_1.Kind.UNION_TYPE_DEFINITION) {
            if (!((_a = definition.types) === null || _a === void 0 ? void 0 : _a.length)) {
                notConvertedTypes.push(definition.name.value);
                return;
            }
            else if (definition.types.length === 1) {
                return {
                    ...parseCommonFields(definition),
                    ...parseType(definition.types[0]),
                };
            }
            else // Multiple types in union => or-type
                return {
                    ...parseCommonFields(definition),
                    type: 'or',
                    or: definition.types.map(type => parseType(type)),
                };
        }
        else if (definition.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION) {
            const fields = (_b = definition.fields) !== null && _b !== void 0 ? _b : [];
            return {
                ...parseCommonFields(definition),
                type: 'object',
                additionalProperties: false,
                properties: Object.fromEntries(fields.map(field => parseObjectField(field, definition)))
            };
        }
        else if (definition.kind === graphql_1.Kind.ENUM_TYPE_DEFINITION) {
            const fields = (_c = definition.values) !== null && _c !== void 0 ? _c : [];
            return {
                ...parseCommonFields(definition),
                type: 'string',
                enum: fields.map(field => field.name.value),
            };
        }
        else {
            if (unsupported === 'ignore') {
                const name = (_d = definition === null || definition === void 0 ? void 0 : definition.name) === null || _d === void 0 ? void 0 : _d.value;
                if (name)
                    notConvertedTypes.push(name);
                return;
            }
            const message = `GraphQL kind ${definition.kind} not supported`;
            const meta = {
                blob: definition,
                source,
                loc: definition.loc,
            };
            if (unsupported === 'warn')
                warn(message, meta);
            else
                throw new core_types_1.UnsupportedError(message, meta);
        }
    })
        .filter((t) => !!t);
    return {
        data: { version: 1, types },
        convertedTypes: types.map(({ name }) => name),
        notConvertedTypes,
    };
}
exports.convertGraphqlToCoreTypes = convertGraphqlToCoreTypes;
function parseCommonFields(type, parent) {
    return {
        name: parseName(type.name),
        ...parseCommonFieldsWithoutName(type, parent),
    };
}
function parseCommonFieldsWithoutName(type, parent) {
    return {
        ...(0, annotation_1.parseDescription)(type.description),
        title: parseTitle(type.name, parent),
        ...(type.loc ? { loc: type.loc } : {}),
    };
}
function parseName(name) {
    return name.value;
}
function parseTitle(name, parent) {
    if (parent === null || parent === void 0 ? void 0 : parent.name)
        return `${parent.name.value}.${name.value}`;
    return name.value;
}
function parseFieldType(field, parent) {
    if (field.kind === graphql_1.Kind.LIST_TYPE)
        return {
            type: 'array',
            elementType: (0, gql_utils_1.isRequired)(field.type)
                ? parseFieldType(field.type.type, parent)
                : {
                    type: "or",
                    or: [
                        { type: 'null' },
                        parseFieldType(field.type, parent),
                    ]
                },
            ...parseCommonFieldsWithoutName({
                ...field,
                name: { kind: graphql_1.Kind.NAME, value: '[]' },
            }, parent),
        };
    else
        return parseType(field);
}
function parseObjectField(field, parent) {
    return [
        parseName(field.name),
        {
            node: {
                ...parseFieldType((0, gql_utils_1.gqlStripRequired)(field.type), parent),
                ...parseCommonFieldsWithoutName(field, parent),
            },
            required: (0, gql_utils_1.isRequired)(field.type),
        }
    ];
}
function parseType(type) {
    const name = parseName(type.name);
    if (name === 'Boolean')
        return { type: 'boolean' };
    else if (name === 'Int')
        return { type: 'integer' };
    else if (name === 'Float')
        return { type: 'number' };
    else if (name === 'String')
        return { type: 'string' };
    else
        return { type: 'ref', ref: name };
}
